Today's agenda
================

09:00 to 10:00 ---> File Upload + File Download
10:00 to 10.40 ---> Breakout + Break
10.40 to 11.20 ---> Session Storage State
11:20 to 11.50 ---> Break + Breakout 
11:50 to 12.30 ---> Parameterization Via JSON File
12.30 to 12:50 ---> Breakout 
12:50 to 01:00 ---> Recap




=================
1. File Upload
* Uploading files using file input elements.  
* Working with drag-and-drop style uploads.  
* Example: Automating resume uploads in job portals.

2. File Download  
* Automating file download process in Playwright.  
* Setting download paths and verifying file content. 
====================================
Breakout Session : File upload using Fileio.com
====================================

3. storage State
*one of those Playwright features that looks small but quietly solves one of the biggest automation headaches 
ever invented: logging in again and again and again.
====================================
Breakout Session : implement session Storage using Leaftaps Application
====================================



------------------------------------------------------------------

# Day 07 Session Recap - Playwright Advanced Handling
 ğŸ“‹ Overview
Yesterday's session covered three advanced Playwright testing scenarios: Alert/Dialog Handling, Frame Handling, and Window/Tab Handling.
---
 1. Alert Handling (`Alert.spec.ts`)
# Key Methods:
- `page.once('dialog')` - Handles a single alert event
- `page.on('dialog')` - Handles multiple alert events
- `alertType.message()` - Extracts alert message
- `alertType.type()` - Gets alert type (alert/confirm/prompt)
- `alertType.accept()` - Click OK button
- `alertType.dismiss()` - Click Cancel button (implied)
# Test Approaches:
1. Auto Dismiss - Playwright auto-dismisses alerts by default
2. Page.Once - Handle first alert only
3. Page.On - Handle multiple alerts with conditional logic based on type
# Important Notes:
====================================
- Use page.on() for multiple alerts
- Use page.once() for single alert scenarios
- Auto-dismiss is default Playwright behavior
====================================
---
 2. Frame Handling (`Frame.spec.ts`)
# Key Methods:
- `page.frames()` - Returns array of all frames (index-based)
- `page.frameLocator(selector)` - Direct frame selection by CSS/XPath //iframe
- `page.frame({url})` - Select frame by URL property
# Test Approaches:
1. Frame by Index - Access frames via `page.frames()[index]`
2. Frame Locator - `page.frameLocator("selector").locator()`
3. Frame by URL - `page.frame({url: 'specific-url'})`
# Important Notes:
====================================
- Frames array includes main page as [0]
- Nested frames can be accessed by index
- Frame index: [0]=main, [1]=1st frame, [2]=2nd frame, etc.
====================================
---
 3. Window Handling (`Window.spec.ts`)
# Key Methods:
- `page.context().waitForEvent('page')` - Capture new window/tab event as promise
- `page.locator(selector).click()` - Trigger child window opening
- `childWindow.title()` - Get title of child window
- `childWindow.locator(selector)` - Perform actions on child window
# Test Approach:
1. Create promise to wait for new page
2. Perform action that opens new window
3. Resolve promise to get child window reference
4. Interact with child window
# Important Notes:
====================================
- Always wrap waitForEvent() in promise BEFORE triggering action
- Use await to resolve the promise after action
- Child window is accessed via the resolved promise variable
====================================
---
 ğŸ¯ Quick Reference Table

| 	Feature	 | 	Method 	| 	Use Case 	|
|-----------------------------|---------------------------|----------------------------|
| Single Alert | `page.once('dialog')` | Handle one alert |
| Multiple Alerts | `page.on('dialog')` | Handle many alerts |
| Frame by Index | `page.frames()[index]` | Access nested frames |
| Frame by Selector | `page.frameLocator()` | Direct CSS/XPath access |
| Frame by URL | `page.frame({url})` | Match by URL property |
| New Window | `waitForEvent('page')` | Capture child window |

---

 âš¡ Key Takeaways
âœ… Use `.on()` for event listeners that need to handle multiple occurrences  
âœ… Frames are zero-indexed; main page is always [0]  
âœ… Always create promise BEFORE triggering new window  
âœ… Type checking (`if/else`) useful for different dialog types  




ğŸ“ Keep your physical notebook and pen handy to sketch out ideas!
------------------------------------------------------------------------------------
# File Upload
--------------
ğŸ‘† Button â†’ ğŸŸ¨ JS Listenerâ†’ ğŸ‘» Hidden Click â†’ ğŸ›¡ï¸ Security Check â†’ âœ… Trusted? â†’  

ğŸ“‚ File Picker â†’ ğŸ‘¤ Pick File â†’ ğŸ“ Update â†’ ğŸ“¦ Files Read  â†’   ğŸ”¥ Event â†’ âš™ï¸ JS Handler â†’ ğŸ‘€ Preview/Upload 

 
Definition:
	Uploading files into a web application using Playwright.
	Playwright simulates attaching files to `<input type="file">` elements or drag-and-drop areas.
---
	 When `type="file"` is Present
	 Directly set the file(s) to the input element.
		const fileInput = page.locator('input[type="file"]');
		await fileInput.setInputFiles('tests/data/sample.pdf');

* Multiple Files:
await fileInput.setInputFiles(['file1.png', 'file2.png']);
---
 When `type="file"` is Not Present (Custom Upload UI)

Some apps hide the `<input>` or use a styled button (drag-drop zones).

https://the-internet.herokuapp.com/upload
Steps:
1. Inspect and find the hidden file input.
2. Use `setFiles` on that hidden element.
Example :
const fileChooser = page.waitForEvent('filechooser',{timeout:10000})
    await page.click('#drag-drop-upload');
    const loaded = await fileChooser
If the input is not accessible at all â†’ Workaround is to use OS-level automation (not Playwrightâ€™s scope).


## Real Problems & Solutions ğŸš¨

| **Problem**            |        **Solution** |
|------------------------|---------------------|
| âŒ CI/CD upload fails | âœ… Check file paths |
| âŒ Hidden file inputs | âœ… Use FileChooser |
| âŒ Drag-drop uploads | âœ… Use direct input |
| âŒ Headless mode | âœ… Debug with screenshots |

---
# File Download
===============
ğŸ¯ Same Format as Your Example: 

ğŸ‘† Button â†’ ğŸŒ HTTP Request â†’ ğŸ–¥ï¸ Server Response â†’ ğŸ“‹ Header Check â†’ â“ attachment? 

â¡ï¸ âœ… Yes â†’ ğŸ“‚ Download Manager â†’ ğŸ’¾ Save Dialog â†’ ğŸ‘¤ Pick Folder â†’ âš™ï¸ Download Starts â†’ ğŸ“Š Progress â†’ âœ… File Saved 
â¡ï¸ âŒ No (inline) â†’ ğŸ‘ï¸ Display in Browser â†’ ğŸ”§ Viewer Loads â†’ ğŸ‘¤ Manual Save Option 
================

Definition :
Handling files downloaded by the application (clicking "Download" links/buttons).

---
 Usage : 

Playwright provides a `page.waitForEvent('download')` listener.

const [download] = await Promise.all([
  page.waitForEvent('download'),      // Wait for download event
  page.click('text=Download Report')  // Trigger download
]);

// Save to desired path
await download.saveAs('downloads/report.pdf');

// Get file path in temp location
console.log(await download.path());

----
path.join()
============
This line tells Playwright where to save the downloaded file.
=============================================================
Now letâ€™s focus on this part:

path.join(__dirname, ../../Data, download.suggestedFilename())

ğŸ”¹ 1. path.join()
-----------------
*Comes from Node.jsâ€™s built-in path module.
*It is used to safely combine multiple parts of a file path.
*It automatically adds / or \ depending on your operating system (Windows, macOS, Linux).

ğŸ‘‰ Example:

path.join("folder", "subfolder", "file.txt")

Result (on Windows):
--------------------
folder\subfolder\file.txt

Result (on Mac/Linux):
-----------------------
folder/subfolder/file.txt

So, path.join() helps build paths without worrying about slashes.

ğŸ”¹ 2. __dirname
Itâ€™s a special variable in Node.js.
It gives the absolute path of the current JavaScript fileâ€™s directory.

ğŸ‘‰ Example: If your file is located in:
-----------------------------------------
C:\Projects\Playwright\Tests\DownloadTest.js

Then:
------
console.log(__dirname)

will print:
--------------
C:\Projects\Playwright\Tests


ğŸ”¹ 3. ../../Data
This part means:

Go two folders up from the current directory (../ twice).
Then go inside the â€œDataâ€ folder.

So if your current file is:
---------------------------
C:\Projects\Playwright\Tests\DownloadTest.js

Then ../../Data points to:
---------------------------
C:\Projects\Data

ğŸ”¹ 4. download.suggestedFilename()
This gives the original name of the file being downloaded (like report.pdf, image.png, etc.).

Playwright reads this automatically from the browserâ€™s download info.
--------------------------------------------------------------------

âœ… "join" is Putting it all together
path.join(__dirname, `../../Data`, fDown.suggestedFilename())

â¡ï¸ means:

Start from the folder where this test file is located (__dirname)
â¡ï¸
Move two levels up to reach the main project folder
â¡ï¸
Go inside the Data folder
â¡ï¸
Add the original file name automatically suggested by the browser.

Result example:
----------------
C:\Projects\Data\JulPw-2.png


Notes:
* Default: Playwright saves downloads in a temporary directory.
* Always use `Promise.all` to avoid missing the download event.
--------------------------------------------------------------------------------------
## How to use timeStamp while saving a downloaded file. :
=========================================================
We want a safe unique time string to use in a filename.
Because this is invalid in Windows:
```
Download_10:45:30.png   âŒ (colon not allowed)
```
So we convert time into a file-friendly format.
## Line 1
new Date()
Means:
ğŸ‘‰ *â€œGive me the current date and time of the systemâ€*
Example output (internally):
```
Sun Feb 08 2026 10:45:30 GMT+0530
```
## Line 2
```
.toISOString()
```
Means:
ğŸ‘‰ â€œConvert the date into a standard string formatâ€
Output:
```
2026-02-08T10:45:30.123Z
```
This is:
YYYY-MM-DDTHH:MM:SS.msZ
## Line 3 (Most Important)
.replace(/[:.]/g, "-")
Means:
ğŸ‘‰ *â€œReplace all `:` and `.` with `-`â€*
Because Windows does not allow `:` in filenames.
So:
Before:
2026-02-08T10:45:30.123Z
After:
2026-02-08T10-45-30-123Z
---
## Final Result Stored in `timestamp`
const timestamp = "2026-02-08T10-45-30-123Z"
Used in filename:
Download_2026-02-08T10-45-30-123Z.png
## One-Line Analogy for Learners
> "We take current time â†’ convert to string â†’ clean it so Windows accepts it as a filename."
---
## Interview-Ready Explanation
If asked in interview:
> *â€œWe use `toISOString()` to get a standard timestamp and `replace()` to remove invalid filename characters, so each downloaded file is uniquely and safely named.â€*



| **Upload â¬†ï¸** | **Download â¬‡ï¸** |
|---------------|-----------------|
| Local â†’ Server | Server â†’ Local |
| Uses `input.files` | Uses `download` event |
| Needs file picker | Needs permission |
| `change` event | Network response |




==================================
1)Breakout activity upload file :
==================================
Url :https://www.file.io/

*<input id="select-files-input" type="file" multiple="" class="css-3fyy40">
*type="file" ----> Then we can upload the file using setInputFiles()
id="select-files-input"

------------------------------------------------------------------------
ğŸ§  First â€” what is a Browser Context?

A BrowserContext is an isolated browser profile.

Think:

Chrome Profile A â†’ cookies + localStorage + sessionStorage
Chrome Profile B â†’ completely separate identity

In Playwright:

const context = await browser.newContext();

Each context has its own:

*cookies

*localStorage

*sessionStorage

*authentication tokens

Basically â†’ its own â€œuserâ€.

ğŸ”¬ What storageState() actually does
=====================================

await context.storageState({ path: 'auth.json' });

This command says:

â€œTake everything that proves this user is logged in and serialize it into a file.â€

It captures:

âœ… Cookies
âœ… Local Storage
âœ… Session Storage (origins-based)

It does NOT save DOM, tabs, or UI state.

Only authentication-related browser storage.

ğŸ“¦ What gets saved (real example)
=================================

The generated file looks like:

{
  "cookies": [
    {
      "name": "session_id",
      "value": "abc123",
      "domain": ".example.com"
    }
  ],
  "origins": [
    {
      "origin": "https://example.com",
      "localStorage": [
        { "name": "token", "value": "jwt-token-value" }
      ]
    }
  ]
}

This is literally your logged-in identity bottled into JSON.

âš™ï¸ How it works internally (browser reality)
======================================

When you log in:

Username + Password
        â†“
Server validates
        â†“
Server sends cookie/token
        â†“
Browser stores it

Next requests automatically include that cookie/token.

Playwright simply exports those stored credentials.

No magic. Just smart persistence.
------------------------------------------
âœ… Typical Workflow (Industry Standard)
Step 1 â€” Login once
*Run this only once.
 await page.context().storageState({ path: 'auth.json' });

Step 2 â€” Reuse login everywhere
test.use({ storageState: 'auth.json' });
*Browser opens already authenticated.
*No login steps executed.
ğŸ§© Important subtle detail

Storage state is tied to:
=========================

*domain
*cookies scope
*same-origin policy

âš™ï¸If your app redirects to another domain (SSO like Microsoft login), storage must include those domains too.
Otherwise authentication appears â€œlostâ€.

âš ï¸ Common misunderstanding

People think this saves session like a snapshot.
It doesnâ€™t.

It saves credentials, not the browser state.
So:
open tabs âŒ
scroll position âŒ
UI elements âŒ
login tokens âœ…

Teams create a global setup:
=============================
globalSetup.spec.ts
   â†“
login once
   â†“
generate auth.json
   â†“
all tests reuse it
===========================================
